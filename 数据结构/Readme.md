# 本部分代码的特点

* 这些代码并不旨在构建能实用的数据结构，而是仅仅实现一下数据结构教材中的思想
* 不对输入数据做范围或非NULL检查，实在要做则选择assert(0)。它与abort()和exit(EXIT_FAILURE)相比能输出报错位置。虽然设计上assert只用于调试，但后两者实在太拉跨；abort根据说明还会dump，但我是没见到，就算有也不会用。总之正确设计是用异常
* 有序结构一般设计成根据key排序，value存放真正的内容，因为value往往无法比较大小；但本部分代码不做这样的考虑
* 命名风格上，如果有“类”，以大写开头，对应的函数以类名开头

## 底层结构

### 数组

* 需要把0或者-1算作无效
* 长度可能不够
* 对于在结构体中的数组考虑使用柔性数组

### 指针

* 需要malloc，就还要管free，还可能内存分配失败
* 指针传递也是值传递，如果只用`Node*`，当需要删除第一个结点或第一个结点不存在进行创建时会处理失败。一种处理方法是单独用一个头结点，它的data可代表长度或无意义，它的next才是第一个结点，但这样会破坏递归定义性，教材上一般就是这种。另一种处理方法是用`Node**`
* remove时返回被移除的结点，否则就内存泄漏了
* 提供init系函数，由调用者分配内存；也提供new系函数，封装init返回堆上指针；其实还可以有create系函数返回栈上对象

## 数据结构

Readme中记录实现数据结构的想法，教材的笔记见[知识笔记](./知识笔记.md)。

### 链表

单向链表最大的问题是append或取末尾每次都要从头遍历一遍，以及不能取出结点后移除它自己。如果采用遵循递归定义性的实现方式，那还可以取出中间的append以及删除之后的；而仅采用头结点的效率就低得可怕了。

单向链表append和取末尾还有一种优化方式，即在头结点中保留一个指向末尾的指针。但这样会导致头结点与普通结点不一致，变得完全只能从外面访问了。

单向链表唯一的优势就是头插和头删除，可用于实现栈和反向。

因此对于实现可用的顺序表，还是用双向链表吧。

### 树

树的特点是递归定义的，即子树也是树，要尽量保证根结点与子结点无区别。

用头指针实现就会遇到上文提过的问题，本代码选择第二种方法实现BST(二叉查找树, Binary Search Tree)。

用数组来实现，一般不使用tree[0]方便乘2，但无法直接保持递归定义性。一种选择是添加index参数。教材一般用本地变量加循环迭代，这样还是破坏了递归定义性，但对于BST来说也不能在子树插入，那就破坏BST了。

### 图

图第一感觉作为容器并不常见，但其实用得很多。它代表的是对其它对象的引用，平常直接用一个泛型列表作为成员就解决了，所以感觉不明显。

## 可实用的数据结构？

在我的构想中，可实用的数据结构的基础就是造一个可自动扩展、可随机访问、强类型的List，再造一个字符串类。可惜实现过程中困难重重，放弃。

Linux内核大量使用了“侵入式链表”这种概念，但要算偏移，我是实现不出来。

## TODO

* 图
* BST的删除
* AVL
