# 数据结构笔记

树和图的笔记在我的博客。

## 基本概念

* 数据结构包括三方面：逻辑结构、存储结构/物理结构（顺序、链式、索引、哈希；有人把链式存储称作随机存储）、数据的运算
  * 可以说逻辑结构独立于存储结构，但反过来不行
  * 两种不同的数据结构，逻辑结构和存储结构可能都相同，如二叉树和二叉排序树
  * 把三方面都描述的称呼：顺序表、哈希表、单链表
  * 可以说某些存储结构能反映数据之间的逻辑关系，其中哈希存储就不能反映
* 算法的特性（必要性）：有穷性（步骤有穷、每步时间有穷；程序可以是无穷的）、确定性（相同输入对应相同输出）、可行性、输入（零或多个）、输出（一或多个）
* 好的算法：正确性、可读性、健壮性、高效
* 流程图：起点终点用圆括号，输入输出用平行四边形，处理用长方形，判断用菱形；NS盒图、伪代码、决策表
* 从大到小：数据（抽象概念） - 数据对象（如数组） - 数据元素（类） - 数据项（属性，是最小单位）

## 时间复杂度

* 是指最坏情况下估算算法执行时间的一个上界
* 与问题的规模和初值状态有关，但也有说最坏情况下只考虑规模的
* 表述：设某某语句的执行次数……则主体语句的执行次数……
* “同一个算法，实现语言的级别越高，执行效率越低”
* 将长度m和n的升序链表合并成一个降序链表，最坏情况下的时间复杂度：以比较次数作为依据而非插入。采用头插法，最好情况下比较min(m,n)次，即一个链表的最大值小于另一个链表的最小值；最坏情况下每次都要两两比较，就是m+n，但选项里没有，又因为2*max(m,n)>=m+n，就选O(max(m,n))

```c
// log以2为底
// logn
while(i<=n)
    i=i*2;
// 表述：i乘以2的次数正是主体语句的执行次数t，因此有2^t<=n，取对数得t<=logn，即O(n)=logn

// nlogn
for(k=1;k<=n;k*=2)    // logn
    for(j=1;j<=n;j++) // n
        count++;

// 三次根号(n)
while(i*i*i<=n) // i <= cbrt(n)
    i++;

// n(n+1)即n^2
for(i=1;i<=n;i++)       // 不能直接乘以n，因为下一句的执行次数与这句有关，只能累加
    for(j=1;j<=2*i;j++) // count执行了2i次
        count++;        // 从里往外分析，这句执行了1次
// Σ(i=1,n)Σ(j=1,2i)1 = Σ(i=1,n)2i = 2Σ(i=1,n)i，用等差数列求和得n(n+1)；注意第一个等号前的东西是1不是j，即2i个1加起来
// 如果是j<=i就只是除以2，仍是O(n^2)；如果是三个变量就是n^3/6

// 递推
题目：T(1)=1，T(n)=2T(n/2)+n，其中n是2的倍数
设n=2^k，T(2^k)=2T(2^(k-1))+2^k=往下递推……，观察得T(2^k) = 2^i * T(2^(k-i)) + i*2^k，当i等于k时带入得T(n)=n(logn+1)

// 级数
幂方级数：比幂次高一阶 T(n)=1^3+2^3+...+n^3，则为O(n^4)
几何级数：与末尾项同阶 T(n)=1+2+4+...+2^n，则为O(2^n)
收敛级数：O(1)
调和级数：O(logn)
对数级数：log1+log2+...+logn = log(n!) = O(nlogn)
```

## 线性表

* 线性表属于逻辑结构中的线性结构，“元素之间的关系是一对一的关系”，指“元素首尾相接”，有顺序
* 线性结构有两种存储结构：顺序存储（元素连续）、链式存储（不同结点储存空间可不连续，结点内的储存单元地址连续；比顺序存储能更方便地表示各种逻辑结构）
* 顺序表：用顺序存储（数组）实现的线性表，支持随机存取（不是存储）
* 链表可以用顺序存储（静态链表），也可以用链式存储；只能顺序存取
* 顺序输出，“链表和顺序表效率相同”
* “在最后一个结点后插入，顺序表比链表效率高”。原因可能是不考虑数组已满、认为不像中间插入数组时要O(n)移动。同时一般认为“链式存储的插入和删除为O(1)”
* 线性表元素的序号从1开始，插入长度为n的顺序表时i的取值范围是[1,n+1]
* 栈、队列、串也是线性结构，它们逻辑结构一样，只是操作的限定不一样
* “串是取值范围受限的线性表”，指的是串的元素只能是字符
* 要求相同数据类型、有限序列

### 链表

* 一般需要有头结点，当没有元素时可以统一处理
* 单链表删除某个结点需要从头找到指定的前一个；另一种方法是把下一个结点的data和next都赋给自己，但这样无法删除最后一个结点
* 循环单链表的next是没有为null的，最后一个指向头指针；因此判断结束/判空的条件是指定指针是否等于头指针
* 静态链表：结点也有data和next，但是整个链表都分配在一个数组里，next的值是数组的下标，最后一个为-1；0号元素即为头结点；在不支持指针的语言中是很巧妙的方法
* 双链表：注意默认是非循环的
* 寻找链表的中点：快慢指针法，快指针走两步，慢指针走一步，快指针到表尾时慢指针就走了一半。未思考边界情况

### 广义表

* LS=(a1, a2..., an)，其中ai可以为原子或子表
* GetHead：取表头，为非空广义表的第一个元素
* GetTail：取表尾，除去表头以外的元素构成的表，即表尾一定是表

## 栈

* 对于某个出栈的元素，在它之前进栈且尚未出的元素必定逆序：比如abc，如果c出来了且ab没出来，则出来的时候必定是ba
* n个不同的元素入栈，可能的出栈序列个数为（卡特兰数）：`1/(n+1)*(2nCn) = 1/(n+1)*(2n)!/(n!*n!)`，1 2 5 14 42
* 应用：进制转换，十进制转二进制时倒序输出、括号匹配、迷宫求解（深度优先搜索）
* 共享栈
  * top0==-1时0号栈为空，top1==MaxSize时1号栈为空
  * top1-top0==1时栈满
  * 能够更有效地利用储存空间，“减少发生上溢的可能”，理由是假如有两个大小为N的栈，任意一个大小大于N就溢出了，而共享栈要两者之和大于2N才会溢出
* 链栈
  * 一般来说“不带头结点”，插入时栈顶指针传的是C++的引用，用x->next=top; top=x修改栈顶指针
* 手动中缀表达式转后缀表达式：按优先级全部加上括号，把所有的符号移到对应的括号后面，去掉所有括号即成。编程实现：遇到操作数统统直接输出，遇到操作符与栈内比较根据优先级进栈或退栈并输出，括号不输出。另一种方法：建立二叉树，后序遍历。后缀表达式的用途：又叫逆波兰表达式，严格按照从左到右计算，将操作数压栈，遇到操作符时弹出两个操作数作为右左，运算结果压栈

## 队列

* 顺序储存/循环队列：队列为空时，front和rear都指向0号元素；入队送到rear然后rear=(rear+1)%MaxSize，出队送出front然后递增；判满：(rear+1)%MaxSize==front，队列长度：(rear+MaxSize-front)%MaxSize
* 链式储存：分为有无头结点，如果无，添加第一个元素时头尾结点都要设为那个结点；无论是否有头结点，删除最后一个元素时头尾节点都要设为NULL，即**头尾指针都可能要修改**
* 双端队列、输入受限的双端队列、输出受限的双端队列
* 如果循环队列里所有的元素都要用上，就又要设一个flag变量，为front==rear且flag==0时为空，1时为满；进队置1，出队置0，因为只有进队会满，出队会空
* 应用：广度优先搜索、缓冲区（消息队列）、页面替换算法中的FIFO
* 输入1,2,3,4，不能通过输入受限的双端队列得到的：4,2,3,1和4,2,1,3；不能通过输出受限的双端队列得到的：4,2,3,1和4,1,3,2

## 矩阵压缩

* 对称矩阵：只存放下三角区和主对角线，注意矩阵是从1行1列开始算的；第1行1个数，第2行2个数，一直加到第i-1行满，第i行是j个数；以上全部算的是数字，变成索引只要-1即可，所以就是`i(i-1)/2+j-1`；若坐标在上三角中，把i和j对调即可
* 三角矩阵：下三角变化则和对称矩阵一致，只需在n+1行第一个位置或认为是数组最后一个位置`n(n+1)/2`存放所有的上三角元素值（一个相等的数）；上三角变化则需要从n加到`n-(i-1)+1`（第i-1行），再加上`(j-i+1)-1`
* 三对角矩阵/带状矩阵：A矩阵的[i,j]在B数组中的索引是`k=2i+j-3`，其中A从[1,1]开始，B从0开始
* 稀疏矩阵：采用{i,j,v}代表一个元素的行 列 值，没有随机存取的特性
