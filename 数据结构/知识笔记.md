# 数据结构笔记

树和图的笔记在我的博客。

## 基本概念

* 数据结构包括三方面：逻辑结构、存储结构/物理结构（顺序、链式、索引、哈希；有人把链式存储称作随机存储）、数据的运算
* 算法的特性：有穷性（程序可以是无穷的）、确定性、可行性；好的算法：正确性、可读性、健壮性、高效
* 流程图：起点终点用圆括号，输入输出用平行四边形，处理用长方形，判断用菱形；NS盒图、伪代码、决策表

## 时间复杂度

* 表述：设某某语句的执行次数……则主体语句的执行次数……

```c
// log以2为底
// logn
while(i<=n)
    i=i*2;
// 表述：i乘以2的次数正是主体语句的执行次数t，因此有2^t<=n，取对数得t<=logn，即O(n)=logn

// nlogn
for(k=1;k<=n;k*=2) // logn
    for(j=1;j<=n;j++) // n
        count++;

// 根号3(n)
while(i*i*i<=n)
    i++;

// n(n+1)即n^2
for(i=1;i<=n;i++) // 不能直接乘以n，因为下一句的执行次数与这句有关，只能累加
    for(j=1;j<=2*i;j++) // count执行了2i次
        count++; // 从里往外分析，这句执行了1次
// Σ(i=1,n)Σ(j=1,2i)1 = Σ(i=1,n)2i = 2Σ(i=1,n)i，用等差数列求和得n(n+1)；注意第一个等号前的东西是1不是j，即2i个1加起来
// 如果是j<=i就只是除以2，仍是O(n^2)；如果是三个变量就是n^3/6

// 递推
题目：T(1)=1，T(n)=2T(n/2)+n
设n=2^k，T(2^k)=2T(2^(k-1))+2^k=……，观察得T(2^k) = 2^i * T(2^(k-i)) + i*2^k，当i等于0时带入得T(n)=n(logn+1)
```

## 线性表

* 线性表属于逻辑结构中的线性结构，“元素之间的关系是一对一的关系”，指“元素首尾相接”，有顺序
* 线性结构有两种存储结构：顺序存储（元素连续）、链式存储
* 顺序表是用顺序存储（数组）实现的线性表，支持随机存取（不是存储）
* 链表可以用顺序存储（静态链表），也可以用链式存储；只能顺序存取
* 顺序输出，“链表和顺序表效率相同”
* “在最后一个结点后插入，顺序表比链表效率高”。原因可能是不考虑数组已满、认为不像中间插入数组时要O(n)移动。但一般来说认为“链式存储的插入和删除为O(1)”
* 线性表元素的序号从1开始，插入长度为n的顺序表时i的取值范围是[1,n+1]
* 栈和串也是线性结构，它们逻辑结构一样，只是操作的限定不一样
* “串是取值范围受限的线性表”，指的是串的元素只能是字符

### 链表

* 一般需要有头结点，当没有元素时可以统一处理
* 单链表删除某个结点需要从头找到指定的前一个；另一种方法是把下一个结点的data和next都赋给自己，但这样无法删除最后一个结点
* 循环单链表的next是没有为null的，最后一个指向头指针；因此判断结束/判空的条件是指定指针是否等于头指针
* 静态链表：结点也有data和next，但是整个链表都分配在一个数组里，next的值是数组的下标，最后一个为-1；0号元素即为头结点；在不支持指针的语言中是很巧妙的方法

### 广义表

* LS=(a1, a2..., an)，其中ai可以为原子或子表
* GetHead：取表头，为非空广义表的第一个元素
* GetTail：取表尾，除去表头以外的元素构成的表，即表尾一定是表

## 栈

* 对于某个出栈的元素，在它之前进栈且尚未出的元素必定逆序：比如abc，如果c出来了且ab没出来，则出来的时候必定是ba
* n个不同的元素入栈，可能的出栈序列个数为（卡特兰数）：`1/(n+1)*(2nCn)=1/(n+1)*(2n)!/(n!*n!)`，1 2 5 14 42
* 应用：十进制转二进制时倒序输出、括号匹配、深度优先搜索
* 共享栈：top0==-1时0号栈为空，top1==MaxSize时1号栈为空；top1-top0==1时栈满；能够更有效地利用储存空间，“减少发生上溢的可能”，理由是假如有两个大小为N的栈，任意一个大小大于N就溢出了，而共享栈要两者之和大于2N才会溢出
* 手动中缀表达式转后缀表达式：按优先级全部加上括号，把所有的符号移到对应的括号后面，去掉所有括号即成。编程实现：遇到操作数统统直接输出，遇到操作符根据优先级进栈或退栈并输出
* 应用：递归、进制转换、括号匹配、迷宫求解

## 队列

* 顺序储存/循环队列：队列为空时，front和rear都指向0号元素；入队送到rear然后rear=(rear+1)%MaxSize，出队送出front然后递增；判满：(rear+1)%MaxSize==front，队列长度：(rear+MaxSize-front)%MaxSize
* 链式储存：分为有无头结点，如果无，添加第一个元素时头尾结点都要设为那个结点；无论是否有头结点，删除最后一个元素时头尾节点都要设为NULL。即**头尾指针都可能要修改**
* 双端队列、输入受限的双端队列、输出受限的双端队列
* 如果循环队列里所有的元素都要用上，就又要设一个flag变量，为front==rear且flag==0时为空，1时为满；进队置1，出队置0，因为只有进队会满，出队会空
* 应用：广度优先搜索、缓冲区（消息队列）、页面替换算法中的FIFO

## 矩阵压缩

* 对称矩阵：只存放下三角区和主对角线，注意矩阵是从1行1列开始算的；第1行1个数，第2行2个数，一直加到第i-1行满，第i行是j个数；以上全部算的是数字，变成索引只要-1即可，所以就是`i(i-1)/2+j-1`；若坐标在上三角中，把i和j对调即可
* 三角矩阵：下三角变化则和对称矩阵一致，只需在n+1行第一个位置或认为是数组最后一个位置`n(n+1)/2` 存放所有的上三角元素值（一个相等的数）；上三角变化则需要从n加到`n-(i-1)+1`（第i-1行），再加上`(j-i+1)-1`
* 三对角矩阵/带状矩阵：`k=2i+j-3`
* 稀疏矩阵：采用{i,j,v}代表一个元素的行 列 值，没有随机存取的特性
