# 数据结构笔记

树和图的笔记在我的博客。

## 基本概念

* 数据结构包括三方面：逻辑结构、存储结构/物理结构（顺序、链式、索引、哈希；有人把链式存储称作随机存储）、数据的运算
* 算法的特性：有穷性（程序可以是无穷的）、确定性、可行性；好的算法：正确性、可读性、健壮性、高效
* 流程图：起点终点用圆括号，输入输出用平行四边形，处理用长方形，判断用菱形；NS盒图、伪代码、决策表

## 时间复杂度

表述：设某某语句的执行次数……则主体语句的执行次数……

```c
// log以2为底
// logn
while(i<=n)
    i=i*2;
// 表述：i乘以2的次数正是主体语句的执行次数t，因此有2^t<=n，取对数得t<=logn，即O(n)=logn

// nlogn
for(k=1;k<=n;k*=2) // logn
    for(j=1;j<=n;j++) // n
        count++;

// 根号3(n)
while(i*i*i<=n)
    i++;

// n(n+1)即n^2
for(i=1;i<=n;i++) // 不能直接乘以n，因为下一句的执行次数与这句有关，只能累加
    for(j=1;j<=2*i;j++) // count执行了2i次
        count++; // 从里往外分析，这句执行了1次
// Σ(i=1,n)Σ(j=1,2i)1 = Σ(i=1,n)2i = 2Σ(i=1,n)i，用等差数列求和得n(n+1)；注意第一个等号前的东西是1不是j，即2i个1加起来
// 如果是j<=i就只是除以2，仍是O(n^2)；如果是三个变量就是n^3/6

{T(n) = 1，若n=1；=2T(n/2)+n，若n>1}
设n=2^k，T(2^k) = 2T(2^(k-1))+2^k=……，观察得T(2^k) = 2^i*T(2^(k-i))+i*2^k，当i等于0时带入得T(n)=n(logn+1)
```

## 线性表

* 线性表属于逻辑结构中的线性结构，“元素之间的关系是一对一的关系”，指“元素首尾相接”；栈和串也是线性结构
* 线性结构有两种存储结构：顺序存储（元素连续）、链式存储
* 顺序表是用顺序存储（数组）实现的线性表，支持随机存取（不是存储）
* 链表可以用顺序存储（静态链表），也可以用链式存储；只能顺序存取
* 顺序输出，链表和顺序表效率相同
* 在最后一个结点后插入，顺序表比链表效率高。原因可能是不考虑已满，或默认是单链表需要从头遍历
* “串是取值范围受限的线性表”，指的是串的元素只能是字符

### 链表

* 一般需要有头结点，当没有元素时可以统一处理
* 单链表删除某个结点需要从头找到指定的前一个；另一种方法是把下一个结点的data和next都赋给自己，但这样无法删除最后一个结点
* 循环单链表的next是没有为null的，最后一个指向头指针；因此判断结束/判空的条件是指定指针是否等于头指针
* 静态链表：结点也有data和next，但是整个链表都分配在一个数组里，next的值是数组的下标，最后一个为-1；0号元素即为头结点；在不支持指针的语言中是很巧妙的方法

### 广义表

* LS=(a1, a2..., an)，其中ai可以为原子或子表
* GetHead：取表头，为非空广义表的第一个元素
* GetTail：取表尾，除去表头以外的元素构成的表，即表尾一定是表

## 栈

* 对于某个出栈的元素，在它之前进栈且尚未出的元素必定逆序：比如abc，如果c出来了且ab没出来，则出来的时候必定是ba
* n个不同的元素入栈，可能的出栈序列个数为（卡特兰数）：`1/(n+1)*(2nCn)=1/(n+1)*(2n)!/(n!*n!)`，1 2 5 14 42
* 应用：十进制转二进制时倒序输出、括号匹配、深度优先搜索
* 共享栈：top0==-1时0号栈为空，top1==MaxSize时1号栈为空；top1-top0==1时栈满；能够更有效地利用储存空间
* 手动中缀表达式转后缀表达式：按优先级全部加上括号，把所有的符号移到对应的括号后面，去掉所有括号即成

## 队列

* 顺序储存/循环队列：队列为空时，front和rear都指向0号元素；入队送到rear然后rear=(rear+1)%MaxSize，出队送出front然后递增；判满：(rear+1)%MaxSize==front，队列长度：(rear+MaxSize-front)%MaxSize
* 链式储存：需要分为有无头结点的链表；如果没有，添加第一个元素/删除最后一个元素时要特殊处理，都赋为那个结点/都设为NULL，也就是**头尾指针都可能要修改**
* 栈和队列的逻辑结构时一样的，都是线性表的限制；存储结构可以一样；是插入、删除操作的限定（数据的运算）不一样
* 双端队列、输入受限的双端队列、输出受限的双端队列
* 如果循环队列里所有的元素都要用上，就又要设一个flag变量，为front==rear且flag==0时为空，1时为满；进队置1，出队置0，因为只有进队会满，出队会空
* 应用：广度优先搜索、缓冲区（消息队列）、页面替换算法中的FIFO

## 矩阵压缩

* 对称矩阵：只存放下三角区和主对角线，注意矩阵是从1行1列开始算的；第1行1个数，第2行2个数，一直加到第i-1行满，第i行是j个数；以上全部算的是数字，变成索引只要-1即可，所以就是`i(i-1)/2+j-1`；若坐标在上三角中，把i和j对调即可
* 三角矩阵：下三角变化则和对称矩阵一致，只需要在n+1行第一个位置（`n(n+1)/2`）存放所有的上三角元素（一个相等的常量）即可；上三角变化则需要从n加到`n-(i-1)+1`（第i-1行），再加上`(j-i+1)-1`
* 三对角矩阵/带状矩阵：`k=2i+j-3`
* 稀疏矩阵：如果用数组储存，三列n行，分别是行、列、值；没有随机访问的特性
